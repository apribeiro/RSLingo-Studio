/*
 * generated by Xtext
 */
package rslingo.rslil.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import rslingo.rslil.rSLIL.Actor;
import rslingo.rslil.rSLIL.Attribute;
import rslingo.rslil.rSLIL.ComposedBy;
import rslingo.rslil.rSLIL.DependsOnActor;
import rslingo.rslil.rSLIL.DependsOnGoal;
import rslingo.rslil.rSLIL.Entity;
import rslingo.rslil.rSLIL.ExtensionPoint;
import rslingo.rslil.rSLIL.FR;
import rslingo.rslil.rSLIL.Field;
import rslingo.rslil.rSLIL.Glossary;
import rslingo.rslil.rSLIL.GlossaryType;
import rslingo.rslil.rSLIL.Goal;
import rslingo.rslil.rSLIL.Model;
import rslingo.rslil.rSLIL.NFR;
import rslingo.rslil.rSLIL.Project;
import rslingo.rslil.rSLIL.RSLILPackage;
import rslingo.rslil.rSLIL.RefActor;
import rslingo.rslil.rSLIL.RefAttribute;
import rslingo.rslil.rSLIL.RefFR;
import rslingo.rslil.rSLIL.RefGlossaryType;
import rslingo.rslil.rSLIL.RefGoal;
import rslingo.rslil.rSLIL.RefNFR;
import rslingo.rslil.rSLIL.RefSystem;
import rslingo.rslil.rSLIL.RefUC;
import rslingo.rslil.rSLIL.Reference;
import rslingo.rslil.rSLIL.Scenario;
import rslingo.rslil.rSLIL.Stakeholder;
import rslingo.rslil.rSLIL.Step;
import rslingo.rslil.rSLIL.Term;
import rslingo.rslil.rSLIL.TermRelation;
import rslingo.rslil.rSLIL.UseCase;
import rslingo.rslil.services.RSLILGrammarAccess;

@SuppressWarnings("all")
public class RSLILSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RSLILGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == RSLILPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case RSLILPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case RSLILPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case RSLILPackage.COMPOSED_BY:
				sequence_ComposedBy(context, (ComposedBy) semanticObject); 
				return; 
			case RSLILPackage.DEPENDS_ON_ACTOR:
				sequence_DependsOnActor(context, (DependsOnActor) semanticObject); 
				return; 
			case RSLILPackage.DEPENDS_ON_GOAL:
				sequence_DependsOnGoal(context, (DependsOnGoal) semanticObject); 
				return; 
			case RSLILPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case RSLILPackage.EXTENSION_POINT:
				sequence_ExtensionPoint(context, (ExtensionPoint) semanticObject); 
				return; 
			case RSLILPackage.FR:
				sequence_FR(context, (FR) semanticObject); 
				return; 
			case RSLILPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case RSLILPackage.GLOSSARY:
				sequence_Glossary(context, (Glossary) semanticObject); 
				return; 
			case RSLILPackage.GLOSSARY_TYPE:
				sequence_GlossaryType(context, (GlossaryType) semanticObject); 
				return; 
			case RSLILPackage.GOAL:
				sequence_Goal(context, (Goal) semanticObject); 
				return; 
			case RSLILPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case RSLILPackage.NFR:
				sequence_NFR(context, (NFR) semanticObject); 
				return; 
			case RSLILPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case RSLILPackage.REF_ACTOR:
				sequence_RefActor(context, (RefActor) semanticObject); 
				return; 
			case RSLILPackage.REF_ATTRIBUTE:
				sequence_RefAttribute(context, (RefAttribute) semanticObject); 
				return; 
			case RSLILPackage.REF_FR:
				sequence_RefFR(context, (RefFR) semanticObject); 
				return; 
			case RSLILPackage.REF_GLOSSARY_TYPE:
				sequence_RefGlossaryType(context, (RefGlossaryType) semanticObject); 
				return; 
			case RSLILPackage.REF_GOAL:
				sequence_RefGoal(context, (RefGoal) semanticObject); 
				return; 
			case RSLILPackage.REF_NFR:
				sequence_RefNFR(context, (RefNFR) semanticObject); 
				return; 
			case RSLILPackage.REF_SYSTEM:
				sequence_RefSystem(context, (RefSystem) semanticObject); 
				return; 
			case RSLILPackage.REF_UC:
				sequence_RefUC(context, (RefUC) semanticObject); 
				return; 
			case RSLILPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case RSLILPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case RSLILPackage.STAKEHOLDER:
				sequence_Stakeholder(context, (Stakeholder) semanticObject); 
				return; 
			case RSLILPackage.STEP:
				sequence_Step(context, (Step) semanticObject); 
				return; 
			case RSLILPackage.SYSTEM:
				sequence_System(context, (rslingo.rslil.rSLIL.System) semanticObject); 
				return; 
			case RSLILPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case RSLILPackage.TERM_RELATION:
				sequence_TermRelation(context, (TermRelation) semanticObject); 
				return; 
			case RSLILPackage.USE_CASE:
				sequence_UseCase(context, (UseCase) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING 
	 *         (type='User' | type='ExternalSystem' | type='Timer') 
	 *         description=STRING 
	 *         stakeholder=[Stakeholder|ID]? 
	 *         dependsOn=DependsOnActor?
	 *     )
	 */
	protected void sequence_Actor(EObject context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         descrition=STRING 
	 *         (
	 *             type='Boolean' | 
	 *             type='Integer' | 
	 *             type='Decimal' | 
	 *             type='Currency' | 
	 *             type='Date' | 
	 *             type='Time' | 
	 *             type='Datetime' | 
	 *             type='Enumeration' | 
	 *             type='Text' | 
	 *             type='Regex' | 
	 *             type='Ref' | 
	 *             type='Image'
	 *         ) 
	 *         field=Field 
	 *         reference=Reference?
	 *     )
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((type='And' | type='Or') refGoal=[Goal|ID])
	 */
	protected void sequence_ComposedBy(EObject context, ComposedBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((type='PartOf' | type='SpecializedFrom') actor=[Actor|ID])
	 */
	protected void sequence_DependsOnActor(EObject context, DependsOnActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((type='Requires' | type='Supports' | type='Obstructs' | type='Conflicts' | type='Identical') refGoal=[Goal|ID])
	 */
	protected void sequence_DependsOnGoal(EObject context, DependsOnGoal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID nameAlias=STRING description=STRING attributes+=Attribute+)
	 */
	protected void sequence_Entity(EObject context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_ExtensionPoint(EObject context, ExtensionPoint semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.EXTENSION_POINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.EXTENSION_POINT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExtensionPointAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING 
	 *         description=STRING 
	 *         (modality='Obligation' | modality='Permission' | modality='Prohibition') 
	 *         (
	 *             actionType='EntityManage' | 
	 *             actionType='EntityBrowse' | 
	 *             actionType='EntitySearch' | 
	 *             actionType='EntityCreate' | 
	 *             actionType='EntityDelete' | 
	 *             actionType='EntitySync' | 
	 *             actionType='Report'
	 *         ) 
	 *         stakeholder=[Stakeholder|ID] 
	 *         (priority='VeryLow' | priority='Low' | priority='Medium' | priority='High' | priority='VeryHigh') 
	 *         depends+=RefFR? 
	 *         partOf=[FR|ID]?
	 *     )
	 */
	protected void sequence_FR(EObject context, FR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (size=INT (multiplicity='0' | multiplicity='1' | multiplicity='0..1' | multiplicity='*' | multiplicity=STRING) defaultValue=STRING?)
	 */
	protected void sequence_Field(EObject context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type='Stakeholder' | type='Entity' | type='Architectural' | type='Actor')
	 */
	protected void sequence_GlossaryType(EObject context, GlossaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING 
	 *         type=RefGlossaryType 
	 *         acronym=STRING 
	 *         description=STRING 
	 *         (pos='Adjective' | pos='Adverb' | pos='Noun' | pos='Verb')? 
	 *         synset=STRING? 
	 *         termRelation+=TermRelation*
	 *     )
	 */
	protected void sequence_Glossary(EObject context, Glossary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         stakeholder=[Stakeholder|ID] 
	 *         (priority='VeryLow' | priority='Low' | priority='Medium' | priority='High' | priority='VeryHigh') 
	 *         dependsOn+=DependsOnGoal* 
	 *         composedBy+=ComposedBy*
	 *     )
	 */
	protected void sequence_Goal(EObject context, Goal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         project=Project 
	 *         systems+=System* 
	 *         glossaries+=Glossary* 
	 *         stakeholders+=Stakeholder* 
	 *         goals+=Goal* 
	 *         entities+=Entity* 
	 *         actors+=Actor* 
	 *         useCases+=UseCase* 
	 *         frs+=FR* 
	 *         nfrs+=NFR*
	 *     )
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING 
	 *         description=STRING 
	 *         (
	 *             type='Security' | 
	 *             type='Performance' | 
	 *             type='Usability' | 
	 *             type='Appearance' | 
	 *             type='Operational' | 
	 *             type='Maintenance' | 
	 *             type='Cultural' | 
	 *             type='Legal'
	 *         ) 
	 *         (
	 *             subType='Security.Privacy' | 
	 *             subType='Security.Integrity' | 
	 *             subType='Usability.EaseOfUse' | 
	 *             subType='Usability.EaseOfLean' | 
	 *             subType='Usability.Accessibility'
	 *         ) 
	 *         (metric='Hours' | metric='Mins' | metric='Secs' | metric='mSecs' | metric='Tasks') 
	 *         value=STRING 
	 *         stakeholder=[Stakeholder|ID] 
	 *         (priority='VeryLow' | priority='Low' | priority='Medium' | priority='High' | priority='VeryHigh') 
	 *         depends+=RefNFR? 
	 *         partOf=[NFR|ID]?
	 *     )
	 */
	protected void sequence_NFR(EObject context, NFR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID nameAlias=STRING description=STRING refSystem=RefSystem?)
	 */
	protected void sequence_Project(EObject context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refActor=[Actor|ID] refs+=Actor*)
	 */
	protected void sequence_RefActor(EObject context, RefActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refAttr=[Attribute|ID] refs+=[Attribute|ID]*)
	 */
	protected void sequence_RefAttribute(EObject context, RefAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refFR=[FR|ID] refs+=[FR|ID]*)
	 */
	protected void sequence_RefFR(EObject context, RefFR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refType=GlossaryType refs+=GlossaryType*)
	 */
	protected void sequence_RefGlossaryType(EObject context, RefGlossaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refGoal=[Goal|ID] refs+=[Goal|ID]*)
	 */
	protected void sequence_RefGoal(EObject context, RefGoal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refNFR=[NFR|ID] refs+=[NFR|ID]*)
	 */
	protected void sequence_RefNFR(EObject context, RefNFR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refSystem=[System|ID] refs+=[System|ID]*)
	 */
	protected void sequence_RefSystem(EObject context, RefSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refUC=[UseCase|ID] refs+=[UseCase|ID]*)
	 */
	protected void sequence_RefUC(EObject context, RefUC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refTo=RefAttribute (multiplicity='0' | multiplicity='1' | multiplicity='0..1' | multiplicity='*' | multiplicity=STRING))
	 */
	protected void sequence_Reference(EObject context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING? (type='Main' | type='Alternative' | type='Exception') (mode='Sequential' | mode='Parallel') steps+=Step*)
	 */
	protected void sequence_Scenario(EObject context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING 
	 *         (type='Group.Organization' | type='Group.BusinessUnit' | type='Group.Team' | type='Individual.Person' | type='Individual.ExternalSystem') 
	 *         (category='Business.User.Direct' | category='Business.User.Indirect' | category='System.Engine') 
	 *         description=STRING? 
	 *         partOf=[Stakeholder|ID]?
	 *     )
	 */
	protected void sequence_Stakeholder(EObject context, Stakeholder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (type='ActorPrepareData' | type='ActorCallSystem' | type='SystemExecutes' | type='SystemReturnResult') 
	 *         description=STRING 
	 *         actor=[Actor|ID]? 
	 *         preConditions=STRING? 
	 *         postConditions=STRING?
	 *     )
	 */
	protected void sequence_Step(EObject context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID nameAlias=STRING description=STRING partOf=[System|ID]?)
	 */
	protected void sequence_System(EObject context, rslingo.rslil.rSLIL.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((type='Antonym' | type='Hypernym' | type='Synonym') term=Term)
	 */
	protected void sequence_TermRelation(EObject context, TermRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refTerm=STRING refs+=STRING*)
	 */
	protected void sequence_Term(EObject context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING 
	 *         (
	 *             type='EntityManage' | 
	 *             type='EntityBrowse' | 
	 *             type='EntitySearch' | 
	 *             type='EntityCreate' | 
	 *             type='EntityDelete' | 
	 *             type='EntitySync' | 
	 *             type='Report'
	 *         ) 
	 *         description=STRING 
	 *         (priotity='VeryLow' | priotity='Low' | priotity='Medium' | priotity='High' | priotity='VeryHigh') 
	 *         goals+=RefGoal* 
	 *         frs+=RefFR* 
	 *         actorInitiates=[Actor|ID] 
	 *         actors=RefActor? 
	 *         preConditions=STRING? 
	 *         postConditions=STRING? 
	 *         includes+=RefUC* 
	 *         (extends+=[UseCase|ID] extPoint=[ExtensionPoint|ID])? 
	 *         extensionnPoints+=ExtensionPoint* 
	 *         scenarios+=Scenario*
	 *     )
	 */
	protected void sequence_UseCase(EObject context, UseCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
