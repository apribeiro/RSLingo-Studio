/*
 * generated by Xtext
 */
package rslingo.rslil.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import rslingo.rslil.rSLIL.Actor;
import rslingo.rslil.rSLIL.ActualSchedule;
import rslingo.rslil.rSLIL.Attribute;
import rslingo.rslil.rSLIL.Check;
import rslingo.rslil.rSLIL.Constraint;
import rslingo.rslil.rSLIL.Date;
import rslingo.rslil.rSLIL.Entity;
import rslingo.rslil.rSLIL.EntityType;
import rslingo.rslil.rSLIL.ExtensionPoint;
import rslingo.rslil.rSLIL.FR;
import rslingo.rslil.rSLIL.ForeignKey;
import rslingo.rslil.rSLIL.GlossaryTerm;
import rslingo.rslil.rSLIL.Goal;
import rslingo.rslil.rSLIL.GoalRelation;
import rslingo.rslil.rSLIL.Import;
import rslingo.rslil.rSLIL.Month;
import rslingo.rslil.rSLIL.Multiplicity;
import rslingo.rslil.rSLIL.Organizations;
import rslingo.rslil.rSLIL.PackageGlossary;
import rslingo.rslil.rSLIL.PackageGoal;
import rslingo.rslil.rSLIL.PackageProject;
import rslingo.rslil.rSLIL.PackageStakeholder;
import rslingo.rslil.rSLIL.PackageSystem;
import rslingo.rslil.rSLIL.PlannedSchedule;
import rslingo.rslil.rSLIL.PrimaryKey;
import rslingo.rslil.rSLIL.Priority;
import rslingo.rslil.rSLIL.Project;
import rslingo.rslil.rSLIL.ProjectProgress;
import rslingo.rslil.rSLIL.QR;
import rslingo.rslil.rSLIL.RSLILPackage;
import rslingo.rslil.rSLIL.RefActor;
import rslingo.rslil.rSLIL.RefAttribute;
import rslingo.rslil.rSLIL.RefEntity;
import rslingo.rslil.rSLIL.RefFR;
import rslingo.rslil.rSLIL.RefGoal;
import rslingo.rslil.rSLIL.RefTermType;
import rslingo.rslil.rSLIL.RefUC;
import rslingo.rslil.rSLIL.RequirementRelation;
import rslingo.rslil.rSLIL.Scenario;
import rslingo.rslil.rSLIL.Stakeholder;
import rslingo.rslil.rSLIL.Step;
import rslingo.rslil.rSLIL.SystemRelation;
import rslingo.rslil.rSLIL.TermType;
import rslingo.rslil.rSLIL.UseCase;
import rslingo.rslil.services.RSLILGrammarAccess;

@SuppressWarnings("all")
public class RSLILSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RSLILGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == RSLILPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case RSLILPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case RSLILPackage.ACTUAL_SCHEDULE:
				sequence_ActualSchedule(context, (ActualSchedule) semanticObject); 
				return; 
			case RSLILPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case RSLILPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case RSLILPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case RSLILPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case RSLILPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case RSLILPackage.ENTITY_TYPE:
				sequence_EntityType(context, (EntityType) semanticObject); 
				return; 
			case RSLILPackage.EXTENSION_POINT:
				sequence_ExtensionPoint(context, (ExtensionPoint) semanticObject); 
				return; 
			case RSLILPackage.FR:
				sequence_FR(context, (FR) semanticObject); 
				return; 
			case RSLILPackage.FOREIGN_KEY:
				sequence_ForeignKey(context, (ForeignKey) semanticObject); 
				return; 
			case RSLILPackage.GLOSSARY_TERM:
				sequence_GlossaryTerm(context, (GlossaryTerm) semanticObject); 
				return; 
			case RSLILPackage.GOAL:
				sequence_Goal(context, (Goal) semanticObject); 
				return; 
			case RSLILPackage.GOAL_RELATION:
				sequence_GoalRelation(context, (GoalRelation) semanticObject); 
				return; 
			case RSLILPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case RSLILPackage.MONTH:
				sequence_Month(context, (Month) semanticObject); 
				return; 
			case RSLILPackage.MULTIPLICITY:
				sequence_Multiplicity(context, (Multiplicity) semanticObject); 
				return; 
			case RSLILPackage.ORGANIZATIONS:
				sequence_Organizations(context, (Organizations) semanticObject); 
				return; 
			case RSLILPackage.PACKAGE_GLOSSARY:
				sequence_PackageGlossary(context, (PackageGlossary) semanticObject); 
				return; 
			case RSLILPackage.PACKAGE_GOAL:
				sequence_PackageGoal(context, (PackageGoal) semanticObject); 
				return; 
			case RSLILPackage.PACKAGE_PROJECT:
				sequence_PackageProject(context, (PackageProject) semanticObject); 
				return; 
			case RSLILPackage.PACKAGE_STAKEHOLDER:
				sequence_PackageStakeholder(context, (PackageStakeholder) semanticObject); 
				return; 
			case RSLILPackage.PACKAGE_SYSTEM:
				sequence_PackageSystem(context, (PackageSystem) semanticObject); 
				return; 
			case RSLILPackage.PLANNED_SCHEDULE:
				sequence_PlannedSchedule(context, (PlannedSchedule) semanticObject); 
				return; 
			case RSLILPackage.PRIMARY_KEY:
				sequence_PrimaryKey(context, (PrimaryKey) semanticObject); 
				return; 
			case RSLILPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case RSLILPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case RSLILPackage.PROJECT_PROGRESS:
				sequence_ProjectProgress(context, (ProjectProgress) semanticObject); 
				return; 
			case RSLILPackage.QR:
				sequence_QR(context, (QR) semanticObject); 
				return; 
			case RSLILPackage.REF_ACTOR:
				sequence_RefActor(context, (RefActor) semanticObject); 
				return; 
			case RSLILPackage.REF_ATTRIBUTE:
				sequence_RefAttribute(context, (RefAttribute) semanticObject); 
				return; 
			case RSLILPackage.REF_ENTITY:
				sequence_RefEntity(context, (RefEntity) semanticObject); 
				return; 
			case RSLILPackage.REF_FR:
				sequence_RefFR(context, (RefFR) semanticObject); 
				return; 
			case RSLILPackage.REF_GOAL:
				sequence_RefGoal(context, (RefGoal) semanticObject); 
				return; 
			case RSLILPackage.REF_TERM_TYPE:
				sequence_RefTermType(context, (RefTermType) semanticObject); 
				return; 
			case RSLILPackage.REF_UC:
				sequence_RefUC(context, (RefUC) semanticObject); 
				return; 
			case RSLILPackage.REQUIREMENT_RELATION:
				sequence_RequirementRelation(context, (RequirementRelation) semanticObject); 
				return; 
			case RSLILPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case RSLILPackage.STAKEHOLDER:
				sequence_Stakeholder(context, (Stakeholder) semanticObject); 
				return; 
			case RSLILPackage.STEP:
				sequence_Step(context, (Step) semanticObject); 
				return; 
			case RSLILPackage.SYSTEM:
				sequence_System(context, (rslingo.rslil.rSLIL.System) semanticObject); 
				return; 
			case RSLILPackage.SYSTEM_RELATION:
				sequence_SystemRelation(context, (SystemRelation) semanticObject); 
				return; 
			case RSLILPackage.TERM_TYPE:
				sequence_TermType(context, (TermType) semanticObject); 
				return; 
			case RSLILPackage.USE_CASE:
				sequence_UseCase(context, (UseCase) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (type='User' | type='ExternalSystem' | type='Timer') 
	 *         stakeholder=[Stakeholder|ID]? 
	 *         actor=[Actor|ID]?
	 *     )
	 */
	protected void sequence_Actor(EObject context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (start=Date end=Date?)
	 */
	protected void sequence_ActualSchedule(EObject context, ActualSchedule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (
	 *             type='Boolean' | 
	 *             type='Integer' | 
	 *             type='Decimal' | 
	 *             type='Currency' | 
	 *             type='Date' | 
	 *             type='Time' | 
	 *             type='Datetime' | 
	 *             type='Enumeration' | 
	 *             type='Text' | 
	 *             type='Regex' | 
	 *             type='URL' | 
	 *             type='Image'
	 *         ) 
	 *         size=INT? 
	 *         multiplicity=Multiplicity? 
	 *         defaultValue=STRING? 
	 *         notNull='NotNull'? 
	 *         unique='Unique'?
	 *     )
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID checkExpression=STRING)
	 */
	protected void sequence_Check(EObject context, Check semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.CHECK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.CHECK__NAME));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.CHECK__CHECK_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.CHECK__CHECK_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCheckAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCheckAccess().getCheckExpressionSTRINGTerminalRuleCall_2_0(), semanticObject.getCheckExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (
	 *             type='Cultural' | 
	 *             type='Legal' | 
	 *             type='Organizational' | 
	 *             type='Physical' | 
	 *             type='Project' | 
	 *             type='Technological' | 
	 *             type='Other'
	 *         ) 
	 *         stakeholder=[Stakeholder|ID]? 
	 *         priority=Priority 
	 *         partOf=[Constraint|ID]? 
	 *         progress=ProjectProgress?
	 *     )
	 */
	protected void sequence_Constraint(EObject context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (day=INT month=Month year=INT)
	 */
	protected void sequence_Date(EObject context, Date semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.DATE__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.DATE__DAY));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.DATE__MONTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.DATE__MONTH));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.DATE__YEAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.DATE__YEAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateAccess().getDayINTTerminalRuleCall_0_0(), semanticObject.getDay());
		feeder.accept(grammarAccess.getDateAccess().getMonthMonthParserRuleCall_2_0(), semanticObject.getMonth());
		feeder.accept(grammarAccess.getDateAccess().getYearINTTerminalRuleCall_4_0(), semanticObject.getYear());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type='Master' | type='Detail' | type='Reference')
	 */
	protected void sequence_EntityType(EObject context, EntityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (type='Principal' | type='Secondary')? 
	 *         attributes+=Attribute+ 
	 *         primaryKey=PrimaryKey? 
	 *         foreignKeys+=ForeignKey* 
	 *         checks+=Check*
	 *     )
	 */
	protected void sequence_Entity(EObject context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_ExtensionPoint(EObject context, ExtensionPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (type='Functional' | type='Behavioral' | type='Data') 
	 *         stakeholder=[Stakeholder|ID]? 
	 *         priority=Priority 
	 *         partOf=[FR|ID]? 
	 *         progress=ProjectProgress?
	 *     )
	 */
	protected void sequence_FR(EObject context, FR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (entity=[Entity|ID] refTo=RefAttribute multiplicity=Multiplicity)
	 */
	protected void sequence_ForeignKey(EObject context, ForeignKey semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.FOREIGN_KEY__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.FOREIGN_KEY__ENTITY));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.FOREIGN_KEY__REF_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.FOREIGN_KEY__REF_TO));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.FOREIGN_KEY__MULTIPLICITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.FOREIGN_KEY__MULTIPLICITY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForeignKeyAccess().getEntityEntityIDTerminalRuleCall_1_0_1(), semanticObject.getEntity());
		feeder.accept(grammarAccess.getForeignKeyAccess().getRefToRefAttributeParserRuleCall_3_0(), semanticObject.getRefTo());
		feeder.accept(grammarAccess.getForeignKeyAccess().getMultiplicityMultiplicityParserRuleCall_6_0(), semanticObject.getMultiplicity());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         type=RefTermType 
	 *         acronym=STRING? 
	 *         (pos='Adjective' | pos='Adverb' | pos='Noun' | pos='Verb')? 
	 *         synonym=STRING? 
	 *         hypernym=STRING?
	 *     )
	 */
	protected void sequence_GlossaryTerm(EObject context, GlossaryTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         source=[Goal|ID] 
	 *         target=[Goal|ID] 
	 *         (type='Requires' | type='Supports' | type='Obstructs' | type='Conflicts' | type='Identical') 
	 *         description=STRING?
	 *     )
	 */
	protected void sequence_GoalRelation(EObject context, GoalRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         stakeholder=[Stakeholder|ID] 
	 *         priority=Priority 
	 *         partOfAnd=[Goal|ID]? 
	 *         partOfOr=[Goal|ID]? 
	 *         progress=ProjectProgress?
	 *     )
	 */
	protected void sequence_Goal(EObject context, Goal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(EObject context, Import semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='Jan' | 
	 *         name='Feb' | 
	 *         name='Mar' | 
	 *         name='Apr' | 
	 *         name='May' | 
	 *         name='Jun' | 
	 *         name='Jul' | 
	 *         name='Aug' | 
	 *         name='Sep' | 
	 *         name='Oct' | 
	 *         name='Nov' | 
	 *         name='Dec'
	 *     )
	 */
	protected void sequence_Month(EObject context, Month semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value='"0"' | value='"1"' | value='"0..1"' | value='"*"' | value=STRING)
	 */
	protected void sequence_Multiplicity(EObject context, Multiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (customer=STRING supplier=STRING partners=STRING)
	 */
	protected void sequence_Organizations(EObject context, Organizations semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.ORGANIZATIONS__CUSTOMER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.ORGANIZATIONS__CUSTOMER));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.ORGANIZATIONS__SUPPLIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.ORGANIZATIONS__SUPPLIER));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.ORGANIZATIONS__PARTNERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.ORGANIZATIONS__PARTNERS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOrganizationsAccess().getCustomerSTRINGTerminalRuleCall_3_0(), semanticObject.getCustomer());
		feeder.accept(grammarAccess.getOrganizationsAccess().getSupplierSTRINGTerminalRuleCall_5_0(), semanticObject.getSupplier());
		feeder.accept(grammarAccess.getOrganizationsAccess().getPartnersSTRINGTerminalRuleCall_7_0(), semanticObject.getPartners());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName glossaryTerms+=GlossaryTerm*)
	 */
	protected void sequence_PackageGlossary(EObject context, PackageGlossary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName goals+=Goal* goalRelations+=GoalRelation*)
	 */
	protected void sequence_PackageGoal(EObject context, PackageGoal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         imports+=Import* 
	 *         project=Project 
	 *         packageGlossary+=PackageGlossary* 
	 *         packageStakeholders+=PackageStakeholder* 
	 *         packageGoals+=PackageGoal* 
	 *         goalRelations+=GoalRelation* 
	 *         packageSystems+=PackageSystem* 
	 *         systemRelations+=SystemRelation*
	 *     )
	 */
	protected void sequence_PackageProject(EObject context, PackageProject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName stakeholders+=Stakeholder*)
	 */
	protected void sequence_PackageStakeholder(EObject context, PackageStakeholder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         imports+=Import* 
	 *         system=System 
	 *         entities+=Entity* 
	 *         actors+=Actor* 
	 *         useCases+=UseCase* 
	 *         frs+=FR* 
	 *         qrs+=QR* 
	 *         constraints+=Constraint* 
	 *         requirementRelations+=RequirementRelation*
	 *     )
	 */
	protected void sequence_PackageSystem(EObject context, PackageSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (start=Date end=Date)
	 */
	protected void sequence_PlannedSchedule(EObject context, PlannedSchedule semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.PLANNED_SCHEDULE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.PLANNED_SCHEDULE__START));
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.PLANNED_SCHEDULE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.PLANNED_SCHEDULE__END));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPlannedScheduleAccess().getStartDateParserRuleCall_3_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getPlannedScheduleAccess().getEndDateParserRuleCall_5_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     refTo=RefAttribute
	 */
	protected void sequence_PrimaryKey(EObject context, PrimaryKey semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLILPackage.Literals.PRIMARY_KEY__REF_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLILPackage.Literals.PRIMARY_KEY__REF_TO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPrimaryKeyAccess().getRefToRefAttributeParserRuleCall_2_0(), semanticObject.getRefTo());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (value='Must' | value='Should' | value='Could' | value='Won't')
	 */
	protected void sequence_Priority(EObject context, Priority semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         value='Not-Plan' | 
	 *         value='Plan' | 
	 *         value='On-Design' | 
	 *         value='On-Develop' | 
	 *         value='On-Test' | 
	 *         value='On-Deploy' | 
	 *         value='Concluded'
	 *     )
	 */
	protected void sequence_ProjectProgress(EObject context, ProjectProgress semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         (
	 *             type='SystemDevelopment' | 
	 *             type='SystemDesign' | 
	 *             type='SystemDeployment' | 
	 *             type='SystemMaintenance' | 
	 *             type='Training' | 
	 *             type='Research' | 
	 *             type='Other'
	 *         ) 
	 *         (
	 *             domain='PublicSector' | 
	 *             domain='Education' | 
	 *             domain='Health' | 
	 *             domain='Telecoms' | 
	 *             domain='Energy&Utilities' | 
	 *             domain='Finance&Banks' | 
	 *             domain='Other'
	 *         ) 
	 *         planned=PlannedSchedule? 
	 *         actual=ActualSchedule? 
	 *         organizations=Organizations? 
	 *         progress=ProjectProgress? 
	 *         summary=STRING 
	 *         description=STRING
	 *     )
	 */
	protected void sequence_Project(EObject context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (
	 *             type='Security' | 
	 *             type='Performance' | 
	 *             type='Usability' | 
	 *             type='Appearance' | 
	 *             type='Operational' | 
	 *             type='Maintenance' | 
	 *             type='Cultural' | 
	 *             type='Legal' | 
	 *             type='Efficiency' | 
	 *             type='Reliability' | 
	 *             type='Interoperability'
	 *         ) 
	 *         (
	 *             subType='Security.Privacy' | 
	 *             subType='Security.Integrity' | 
	 *             subType='Usability.EaseOfUse' | 
	 *             subType='Usability.EaseOfLearn' | 
	 *             subType='Usability.Accessibility' | 
	 *             subType='Usability.Understandability' | 
	 *             subType='Usability.Learnability' | 
	 *             subType='Usability.Attractiveness' | 
	 *             subType='Efficiency.ResourceUse'
	 *         )? 
	 *         (
	 *             metric='Hours' | 
	 *             metric='Mins' | 
	 *             metric='Secs' | 
	 *             metric='mSecs' | 
	 *             metric='Tasks' | 
	 *             metric='Other'
	 *         ) 
	 *         value=INT 
	 *         stakeholder=[Stakeholder|ID]? 
	 *         priority=Priority 
	 *         partOf=[QR|ID]? 
	 *         progress=ProjectProgress?
	 *     )
	 */
	protected void sequence_QR(EObject context, QR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refActor=[Actor|ID] refs+=[Actor|ID]*)
	 */
	protected void sequence_RefActor(EObject context, RefActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refAttr=[Attribute|ID] refs+=[Attribute|ID]*)
	 */
	protected void sequence_RefAttribute(EObject context, RefAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refEntity=[Entity|ID] type=EntityType (refs+=[Entity|ID] refType+=EntityType)*)
	 */
	protected void sequence_RefEntity(EObject context, RefEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refFR=[FR|ID] refs+=[FR|ID]*)
	 */
	protected void sequence_RefFR(EObject context, RefFR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refGoal=[Goal|ID] refs+=[Goal|ID]*)
	 */
	protected void sequence_RefGoal(EObject context, RefGoal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refType=TermType refs+=TermType*)
	 */
	protected void sequence_RefTermType(EObject context, RefTermType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refUC=[UseCase|ID] refs+=[UseCase|ID]*)
	 */
	protected void sequence_RefUC(EObject context, RefUC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         source=[Requirement|ID] 
	 *         target=[Requirement|ID] 
	 *         (type='Requires' | type='Supports' | type='Obstructs' | type='Conflicts' | type='Identical') 
	 *         description=STRING?
	 *     )
	 */
	protected void sequence_RequirementRelation(EObject context, RequirementRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (type='Main' | type='Alternative' | type='Exception') 
	 *         (mode='Sequential' | mode='Parallel') 
	 *         steps+=Step*
	 *     )
	 */
	protected void sequence_Scenario(EObject context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (type='Group.Organization' | type='Group.BusinessUnit' | type='Group.Team' | type='Individual.Person' | type='Individual.ExternalSystem') 
	 *         (
	 *             category='Business' | 
	 *             category='Business.Customer' | 
	 *             category='Business.Customer.Sponsor' | 
	 *             category='Business.Customer.Champion' | 
	 *             category='Business.Customer.Other' | 
	 *             category='Business.User.Direct' | 
	 *             category='Business.User.Indirect' | 
	 *             category='Business.Advisor.DomainExpert' | 
	 *             category='Business.Advisor.Trainer' | 
	 *             category='Business.Advisor.RegulatorAgent' | 
	 *             category='Business.System' | 
	 *             category='Technical' | 
	 *             category='Technical.BusinessAnalyst' | 
	 *             category='Technical.Requirements.Engineer' | 
	 *             category='Technical.Software.Architect' | 
	 *             category='Technical.Software.Designer' | 
	 *             category='Technical.Software.Tester'
	 *         ) 
	 *         isA=[Stakeholder|ID]? 
	 *         partOf=[Stakeholder|ID]?
	 *     )
	 */
	protected void sequence_Stakeholder(EObject context, Stakeholder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (type='ActorPrepareData' | type='ActorCallSystem' | type='SystemExecutes' | type='SystemReturnResult' | type='Other') 
	 *         actor=[Actor|ID]? 
	 *         preConditions=STRING? 
	 *         postConditions=STRING? 
	 *         next=[Step|ID]?
	 *     )
	 */
	protected void sequence_Step(EObject context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         source=[System|ID] 
	 *         target=[System|ID] 
	 *         (
	 *             category='Import' | 
	 *             category='Export' | 
	 *             category='Import-Export' | 
	 *             category='Sync' | 
	 *             category='Interact' | 
	 *             category='Other'
	 *         ) 
	 *         (type='In' | type='Out' | type='In-Out') 
	 *         description=STRING?
	 *     )
	 */
	protected void sequence_SystemRelation(EObject context, SystemRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (type='System' | type='Sub-System' | type='Reusable-System' | type='Other') 
	 *         (scope='In' | scope='Out') 
	 *         partOf=[System|ID]?
	 *     )
	 */
	protected void sequence_System(EObject context, rslingo.rslil.rSLIL.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type='Stakeholder' | type='Entity' | type='Architectural' | type='Actor')
	 */
	protected void sequence_TermType(EObject context, TermType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         nameAlias=STRING? 
	 *         description=STRING? 
	 *         (
	 *             type='EntityManage' | 
	 *             type='EntityBrowse' | 
	 *             type='EntitySearch' | 
	 *             type='EntityCreate' | 
	 *             type='EntityDelete' | 
	 *             type='EntitySync' | 
	 *             type='Report'
	 *         ) 
	 *         entities=RefEntity? 
	 *         priority=Priority 
	 *         extensionPoints+=ExtensionPoint* 
	 *         goals+=RefGoal* 
	 *         frs+=RefFR* 
	 *         actorInitiates=[Actor|ID] 
	 *         actors=RefActor? 
	 *         preConditions=STRING? 
	 *         postConditions=STRING? 
	 *         includes+=RefUC* 
	 *         (extends=[UseCase|ID] extPoint=[ExtensionPoint|ID])? 
	 *         scenarios+=Scenario*
	 *     )
	 */
	protected void sequence_UseCase(EObject context, UseCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
